---
sort: 2
---

# 面试题

## Java基础

### object有什么方法
1. clone方法：保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常
2. getClass方法：final方法，获得运行时类型
3. toString方法：一般用于打印对象信息
4. finalize方法：该方法用于释放资源
5. equals方法：用于判断是否为同一个对象地址
6. hashcode方法：
7. wait方法
8. notify方法
9. notifyAll方法


### Thread有什么方法
1. start方法：通知线程规划器可以运行此线程
2. run方法
3. isAlive方法：判断当前线程是否处于活动状态
4. getPriority方法：获取当前线程的优先级
5. setPriority方法：设置当前线程的优先级，默认优先级是5，取值为1-10
6. isDaeMon方法：判断线程是否为守护线程
7. setDaemon方法：设置线程为守护线程
8. interrupt方法：这个方法不会中断线程。实际上调用interrupt实际作用是在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞状态
9. join方法：让该线程无限阻塞，直到该线程销毁为止，内部使用了wait()，所以会释放锁
10. currentThead方法，返回当前正在执行的线程对象的引用
11. sleep方法：在指定的时间让正在执行的线程休眠。不会释放锁
12. yield方法：暂停当前执行的线程对象，并执行其他线程。会放弃cpu资源，放弃的时间不确定

### ThreadLocal是什么，它的使用场景

### 线程的状态

### 线程怎么处理异常
实现Thread.UncaughtExceptionHandler的接口中的uncaughtException方法

### cglib和jdk动态代理的区别
1. Jdk动态代理：利用拦截器（必须实现InvocationHandler）加上反射机制生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理

2. Cglib动态代理：利用ASM框架，对代理对象类生成的class文件加载进来，通过修改其字节码生成子类来处理

### ReentrantLock怎么重入锁

### ReentrantLock和synchronized的区别 

### 多线程怎么交错执行
1. Semaphore(信号量)  使用acquire(阻塞)和release(释放) 
2. ReenetrantLock获取Condition，使用signal（释放）和await（阻塞）

### AQS是什么，有什么用
AQS中同步等待队列的实现是一个带头尾指针(这里用指针表示引用是为了后面讲解源码时可以更直观形象,况且引用本身是一种受限的指针)
且不带哨兵结点(后文中的头结点表示队列首元素结点,不是指哨兵结点)的双向链表

### HashMap和ConcurrentHashMap

## JVM

### JVM底层的有哪几种垃圾回收算法，有什么区别。简述一下你了解的垃圾回收器有哪些，有什么区别
标记-清除算法
从算法的名称上可以看出，这个算法分为两部分，标记和清除。首先标记出所有需要被回收的对象，然后在标记完成后统一回收掉所有被标记的对象
缺点：一是标记和清除的效率不是很高；二是标记和清除后会产生很多的内存碎片，导致可用的内存空间不连续，当分配大对象的时候，没有足够的空间时不得不提前触发一次垃圾回收

复制算法
这个算法将可用的内存空间分为大小相等的两块，每次只是用其中的一块，当这一块被用完的时候，就将还存活的对象复制到另一块中，然后把原已使用过的那一块内存空间一次回收掉。这个算法常用于新生代的垃圾回收。
复制算法解决了标记-清除算法的效率问题，以空间换时间，但是当存活对象非常多的时候，复制操作效率将会变低，而且每次只能使用一半的内存空间，利用率不高

标记-整理算法
这个算法分为三部分：一是标记出所有需要被回收的对象；二是把所有存活的对象都向一端移动；三是把所有存活对象边界以外的内存空间都回收掉。
标记-整理算法解决了复制算法多复制效率低、空间利用率低的问题，同时也解决了内存碎片的问题
分代收集算法
根据对象生存周期的不同将内存空间划分为不同的块，然后对不同的块使用不同的回收算法。一般把Java堆分为新生代和老年代，新生代中对象的存活周期短，只有少量存活的对象，所以可以使用复制算法，而老年代中对象存活时间长，而且对象比较多，所以可以采用标记-清除和标记-整理算法。

新生代收集器：Serial、ParNew、Parallel Scavenge
老年代收集器：CMS、Serial Old、Parallel Old
整堆收集器： G1

## Spring

## Mysql

### 行锁和表锁，怎么设置行锁

表锁的命令：
	lock tables 表名 read/write
	unlock tables;
行锁的命令： 在select 语句后面加上 for update

### 主键索引为什么建议用自增id
Mysql InnoDB引擎底层数据结构是B+树
主要目的就是为了 提高范围查询效率、增加排序效率、提高扫表能力和顺序访问
在底层是以数据页为单位来存储数据的，默认大小为16k
如果主键为自增Id的话，mysql写满一个数据页的时候，直接申请另一个新的数据页接着写就可以了
如果主键非自增Id,为了确保索引有序，mysql就需要将每次插入的数据都放在合适的位置，当一个页快满或已满时，新插入数据的时候，Mysql就需要申请新的数据页，并且把上一个数据页中的部分数据挪到新的数据页，这就造成了页分裂，这个大量移动数据会影响插入效率
主键占用空间越大，每个页存储的主键个数越少，路树就越少，B+树的深度会变长，导致IO次数变多
普通索引的叶子节点上保存的是主键Id的值，如果主键Id占空间较大，将会成倍增加mysql空间占用大小

### 什么时候索引失效

### 索引的类型
1. 普通索引：index
2. 唯一索引: unique index
3. 主键索引: primary key
4. 组合索引: index(col1,col2)
5. 全文索引: fulltext

### 索引的结构
B+Tree、hash

## Zookeeper

### zookeeper是怎么保证强一致性

### CAP是什么
C: 一致性
A: 可用性
P: 分区容错性

## Dubbo

### dubbo是怎么暴露服务

## Netty

## Redis
