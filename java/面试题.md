---
sort: 99
---

# 面试题

## Java基础

### object有什么方法
1. clone方法：保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常
2. getClass方法：final方法，获得运行时类型
3. toString方法：一般用于打印对象信息
4. finalize方法：该方法用于释放资源
5. equals方法：用于判断是否为同一个对象地址
6. hashcode方法：
7. wait方法
8. notify方法
9. notifyAll方法


### Thread有什么方法

1. start方法：通知线程规划器可以运行此线程
2. run方法
3. isAlive方法：判断当前线程是否处于活动状态
4. getPriority方法：获取当前线程的优先级
5. setPriority方法：设置当前线程的优先级，默认优先级是5，取值为1-10
6. isDaeMon方法：判断线程是否为守护线程
7. setDaemon方法：设置线程为守护线程
8. interrupt方法：这个方法不会中断线程。实际上调用interrupt实际作用是在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞状态
9. join方法：让该线程无限阻塞，直到该线程销毁为止，内部使用了wait()，所以会释放锁
10. currentThead方法，返回当前正在执行的线程对象的引用
11. sleep方法：在指定的时间让正在执行的线程休眠。不会释放锁
12. yield方法：暂停当前执行的线程对象，并执行其他线程。会放弃cpu资源，放弃的时间不确定

### ThreadLocal是什么，它的使用场景

### 线程的状态

### 线程怎么处理异常
实现Thread.UncaughtExceptionHandler的接口中的uncaughtException方法

### cglib和jdk动态代理的区别
1. Jdk动态代理：利用拦截器（必须实现InvocationHandler）加上反射机制生成一个代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理

2. Cglib动态代理：利用ASM框架，对代理对象类生成的class文件加载进来，通过修改其字节码生成子类来处理

### ReentrantLock怎么重入锁

### ReentrantLock和synchronized的区别 

### 多线程怎么交错执行
1. Semaphore(信号量)  使用acquire(阻塞)和release(释放) 
2. ReenetrantLock获取Condition，使用signal（释放）和await（阻塞）

### AQS是什么，有什么用
AQS（AbstractQueuedSynchronizer 类）是一个用来构建锁和同步器的框架，各种 Lock 包中的锁（常用的有 ReentrantLock、ReadWriteLock），
以及其他如 Semaphore、CountDownLatch，甚至是早期的 FutureTask 等，都是基于 AQS 来构建。

### HashMap和ConcurrentHashMap

### 简述一下ConcrrentHashMap插入数据的流程
判断Node[]数组是否初始化，没有则进行初始化操作
通过hash定位数组的索引坐标，是否有Node节点，如果没有则使用CAS进行添加（链表的头节点），添加失败则进入下次循环。
检查到内部正在扩容，就帮助它一块扩容。
如果f！=null，则使用synchronized锁住f元素（链表/红黑树的头元素）。如果是Node（链表结构）则执行链表的添加操作；如果是TreeNode（树型结构）则执行树添加操作。
判断链表长度已经达到临界值8（默认值），当节点超过这个值就需要把链表转换为树结构。
如果添加成功就调用addCount（）方法统计size，并且检查是否需要扩容

### Java有什么优势和缺点

### java为什么是面向接口
代码的灵活性和高可复用性
良好的可扩展性
低耦合

### java为什么不能多继承

### 深克隆用cloneable怎么写

克隆除自身以外所有的对象，包括自身所包含的所有对象实例。由具体的需求决定深克隆的层次(N层克隆)。


## JVM

### JVM底层的有哪几种垃圾回收算法，有什么区别。简述一下你了解的垃圾回收器有哪些，有什么区别
标记-清除算法
从算法的名称上可以看出，这个算法分为两部分，标记和清除。首先标记出所有需要被回收的对象，然后在标记完成后统一回收掉所有被标记的对象
缺点：一是标记和清除的效率不是很高；二是标记和清除后会产生很多的内存碎片，导致可用的内存空间不连续，当分配大对象的时候，没有足够的空间时不得不提前触发一次垃圾回收

复制算法
这个算法将可用的内存空间分为大小相等的两块，每次只是用其中的一块，当这一块被用完的时候，就将还存活的对象复制到另一块中，然后把原已使用过的那一块内存空间一次回收掉。这个算法常用于新生代的垃圾回收。
复制算法解决了标记-清除算法的效率问题，以空间换时间，但是当存活对象非常多的时候，复制操作效率将会变低，而且每次只能使用一半的内存空间，利用率不高

标记-整理算法
这个算法分为三部分：一是标记出所有需要被回收的对象；二是把所有存活的对象都向一端移动；三是把所有存活对象边界以外的内存空间都回收掉。
标记-整理算法解决了复制算法多复制效率低、空间利用率低的问题，同时也解决了内存碎片的问题
分代收集算法
根据对象生存周期的不同将内存空间划分为不同的块，然后对不同的块使用不同的回收算法。一般把Java堆分为新生代和老年代，新生代中对象的存活周期短，只有少量存活的对象，所以可以使用复制算法，而老年代中对象存活时间长，而且对象比较多，所以可以采用标记-清除和标记-整理算法。

新生代收集器：Serial、ParNew、Parallel Scavenge
老年代收集器：CMS、Serial Old、Parallel Old
整堆收集器： G1

### 如果cpu占用率过高，如何定位到是项目中哪一行代码出了问题
top --->   定位cpu最高的进程pid ---->    jps -l |grep 进程pid   ----->   ps -mp 进程pid -o THREAD,tid,time（tid）  ----->  printf '%x\n' 线程tid  ----->   jstack 进程pid | grep 线程tid -A60

## Spring

## Spring Boot

### 对于springboot来说，最为重要的注解应该是@SpringBootApplication了，请谈一下你对这个注解的理解

整合了@SpringBootConfiguration/@EnableAutoConfiguration/@ComponentScan

### SpringBoot中有有一个注解@ComponentScan,请谈谈你对这个注解的认识
扫描当前项目指定包名下配置了@Component注解的类，并变成BeanDefinition对象

### SpringBoot 中有一个注解@EnableAutoConfiguration，谈谈这个注解的认识
在AutoConfigurationImportSelector收集这个注解的类
然后再ConfigurationClassPostProcessor变成BeanDefinition对象

### META-INF/spring.factory配置文件对于SpringBoot的自动配置很重要，为什么
spring通过spi加载配置文件的方式，把类加载到spring容器完成实例化

### 你了解SpringBoot官方给出的Starter工程的命名规范么，具体是什么
官方给出的starter命名是spring-boot-starter-xxx
自定义的是xxx-spring-boot-starter

### @Configuration所注解的类称为配置类，其中@Bean方法可以创建相应实例，这些@Bean方法实例创建的顺序是什么

按照定义的方法的自然顺序

### 定义Starter的定义步骤
1. 创建自动配置工程 一般都是公共功能的封装
2. 定义pom工程 负责去导入共用功能的工程

### 在自动配置类中，一般会涉及到很多条件注解，简单介绍一下


### SpringBoot的启动过程


### SpringBoot自动配置的理解

## Mysql

### 行锁和表锁，怎么设置行锁

表锁的命令：
	lock tables 表名 read/write
	unlock tables;
行锁的命令： 在select 语句后面加上 for update

### 主键索引为什么建议用自增id
Mysql InnoDB引擎底层数据结构是B+树
主要目的就是为了 提高范围查询效率、增加排序效率、提高扫表能力和顺序访问
在底层是以数据页为单位来存储数据的，默认大小为16k
如果主键为自增Id的话，mysql写满一个数据页的时候，直接申请另一个新的数据页接着写就可以了
如果主键非自增Id,为了确保索引有序，mysql就需要将每次插入的数据都放在合适的位置，当一个页快满或已满时，新插入数据的时候，Mysql就需要申请新的数据页，并且把上一个数据页中的部分数据挪到新的数据页，这就造成了页分裂，这个大量移动数据会影响插入效率
主键占用空间越大，每个页存储的主键个数越少，路树就越少，B+树的深度会变长，导致IO次数变多
普通索引的叶子节点上保存的是主键Id的值，如果主键Id占空间较大，将会成倍增加mysql空间占用大小

### 什么时候索引失效

### 索引的类型
1. 普通索引：index
2. 唯一索引: unique index
3. 主键索引: primary key
4. 组合索引: index(col1,col2)
5. 全文索引: fulltext

### 索引的结构
B+Tree、hash

## Zookeeper

### zookeeper是怎么保证数据一致性

依赖于ZAB协议的消息广播、崩溃恢复和数据同步


### CAP是什么
C: 一致性
A: 可用性
P: 分区容错性

## Dubbo

### dubbo是怎么暴露服务

开启Server并监听指定端口
将请求数据进行反序列化
Exchanger负责解析Request对象
通过Protocol层，根据具体协议解析Request对象
对服务提供者的服务实现类进行代理

### dubbo是怎么引用服务

服务的引入时机有两种，第一种是饿汉式，第二种是懒汉式。
饿汉式就是加载完毕就会引入，懒汉式是只有当这个服务被注入到其他类中时启动引入流程，默认是懒汉式。
会先根据配置参数组装成 URL ，一般而言我们都会配置的注册中心，所以会构建 RegistryDirectory向注册中心注册消费者的信息，并且订阅提供者、配置、路由等节点。
得知提供者的信息之后会进入 Dubbo 协议的引入，会创建 Invoker ，期间会包含 NettyClient，来进行远程通信，最后通过 Cluster 来包装 Invoker，默认是 FailoverCluster，最终返回代理类。


## Netty

### http协议三次握手和四次挥手
三次握手：
第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

四次挥手：
第一次挥手:客户端A发送一个FIN.用来关闭客户A到服务器B的数据传送
第二次挥手:服务器B收到这个FIN. 它发回一个ACK，确认序号为收到的序号+1。和SYN一样，一个FIN将占用一个序号
第三次挥手:服务器B关闭与客户端A的连接，发送一个FIN给客户端A
第四次挥手:客户端A发回ACK报文确认，并将确认序号设置为序号加1

### 以太网为什么是1500字节


### ip为什么是64k


## Redis

### Redis如何解决缓存雪崩，击穿，穿透
雪崩： 当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力
击穿： key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮
穿透： key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源


## 项目
 
### 如何设计秒杀系统
1. 将秒杀系统独立部署，独立域名
2. 页面内容静态化
3. 设置各区域cdn，然后将秒杀商品页面缓存到cdn
4. 限制前端用户的点击频率
5. nginx层针对同一个ip的访问频率限流
6. 同一个查询层在网关层的限流
7. 读请求用redis来设计(可以用分段lua)，写请求用队列，由并行转串行
8. 数据库分库分表
